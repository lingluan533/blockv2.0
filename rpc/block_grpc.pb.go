// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryServiceClient interface {
	//查询所有的存证记录
	QueryAllReceipt(ctx context.Context, in *RequestAllDataReceipts, opts ...grpc.CallOption) (*ResponseAllDataReceipts, error)
	QueryBlockBatch(ctx context.Context, in *RequestDataBatch, opts ...grpc.CallOption) (*ResponseDataBatchBlock, error)
	QueryBlock(ctx context.Context, in *RequestBlock, opts ...grpc.CallOption) (*ResponseBlock, error)
	// rpc queryGenesisBlock(RequestGenesisBlock) returns(ResponseGenesisBlock){}
	QueryTx(ctx context.Context, in *RequestTx, opts ...grpc.CallOption) (*ResponseTx, error)
	QueryDataReceipt(ctx context.Context, in *RequestDataReceipt, opts ...grpc.CallOption) (*ResponseDataReceipt, error)
}

type queryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryServiceClient(cc grpc.ClientConnInterface) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) QueryAllReceipt(ctx context.Context, in *RequestAllDataReceipts, opts ...grpc.CallOption) (*ResponseAllDataReceipts, error) {
	out := new(ResponseAllDataReceipts)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryAllReceipt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryBlockBatch(ctx context.Context, in *RequestDataBatch, opts ...grpc.CallOption) (*ResponseDataBatchBlock, error) {
	out := new(ResponseDataBatchBlock)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryBlockBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryBlock(ctx context.Context, in *RequestBlock, opts ...grpc.CallOption) (*ResponseBlock, error) {
	out := new(ResponseBlock)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryTx(ctx context.Context, in *RequestTx, opts ...grpc.CallOption) (*ResponseTx, error) {
	out := new(ResponseTx)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryDataReceipt(ctx context.Context, in *RequestDataReceipt, opts ...grpc.CallOption) (*ResponseDataReceipt, error) {
	out := new(ResponseDataReceipt)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryDataReceipt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServiceServer is the server API for QueryService service.
// All implementations should embed UnimplementedQueryServiceServer
// for forward compatibility
type QueryServiceServer interface {
	//查询所有的存证记录
	QueryAllReceipt(context.Context, *RequestAllDataReceipts) (*ResponseAllDataReceipts, error)
	QueryBlockBatch(context.Context, *RequestDataBatch) (*ResponseDataBatchBlock, error)
	QueryBlock(context.Context, *RequestBlock) (*ResponseBlock, error)
	// rpc queryGenesisBlock(RequestGenesisBlock) returns(ResponseGenesisBlock){}
	QueryTx(context.Context, *RequestTx) (*ResponseTx, error)
	QueryDataReceipt(context.Context, *RequestDataReceipt) (*ResponseDataReceipt, error)
}

// UnimplementedQueryServiceServer should be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (UnimplementedQueryServiceServer) QueryAllReceipt(context.Context, *RequestAllDataReceipts) (*ResponseAllDataReceipts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllReceipt not implemented")
}
func (UnimplementedQueryServiceServer) QueryBlockBatch(context.Context, *RequestDataBatch) (*ResponseDataBatchBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryBlockBatch not implemented")
}
func (UnimplementedQueryServiceServer) QueryBlock(context.Context, *RequestBlock) (*ResponseBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryBlock not implemented")
}
func (UnimplementedQueryServiceServer) QueryTx(context.Context, *RequestTx) (*ResponseTx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTx not implemented")
}
func (UnimplementedQueryServiceServer) QueryDataReceipt(context.Context, *RequestDataReceipt) (*ResponseDataReceipt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDataReceipt not implemented")
}

// UnsafeQueryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServiceServer will
// result in compilation errors.
type UnsafeQueryServiceServer interface {
	mustEmbedUnimplementedQueryServiceServer()
}

func RegisterQueryServiceServer(s grpc.ServiceRegistrar, srv QueryServiceServer) {
	s.RegisterService(&QueryService_ServiceDesc, srv)
}

func _QueryService_QueryAllReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestAllDataReceipts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryAllReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryAllReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryAllReceipt(ctx, req.(*RequestAllDataReceipts))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryBlockBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDataBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryBlockBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryBlockBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryBlockBatch(ctx, req.(*RequestDataBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryBlock(ctx, req.(*RequestBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryTx(ctx, req.(*RequestTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryDataReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDataReceipt)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryDataReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryDataReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryDataReceipt(ctx, req.(*RequestDataReceipt))
	}
	return interceptor(ctx, in, info, handler)
}

// QueryService_ServiceDesc is the grpc.ServiceDesc for QueryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "queryAllReceipt",
			Handler:    _QueryService_QueryAllReceipt_Handler,
		},
		{
			MethodName: "queryBlockBatch",
			Handler:    _QueryService_QueryBlockBatch_Handler,
		},
		{
			MethodName: "queryBlock",
			Handler:    _QueryService_QueryBlock_Handler,
		},
		{
			MethodName: "queryTx",
			Handler:    _QueryService_QueryTx_Handler,
		},
		{
			MethodName: "queryDataReceipt",
			Handler:    _QueryService_QueryDataReceipt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}

// ToUpperClient is the client API for ToUpper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ToUpperClient interface {
	Upper(ctx context.Context, in *UpperRequest, opts ...grpc.CallOption) (*UpperReply, error)
	NodeCredible(ctx context.Context, in *NodeCredibleData, opts ...grpc.CallOption) (*Response, error)
	Video(ctx context.Context, in *VideoData, opts ...grpc.CallOption) (*Response, error)
	Sensor(ctx context.Context, in *SensorData, opts ...grpc.CallOption) (*Response, error)
	UserBehaviour(ctx context.Context, in *UserBehaviourData, opts ...grpc.CallOption) (*Response, error)
	ServiceAccess(ctx context.Context, in *ServiceAccessData, opts ...grpc.CallOption) (*Response, error)
}

type toUpperClient struct {
	cc grpc.ClientConnInterface
}

func NewToUpperClient(cc grpc.ClientConnInterface) ToUpperClient {
	return &toUpperClient{cc}
}

func (c *toUpperClient) Upper(ctx context.Context, in *UpperRequest, opts ...grpc.CallOption) (*UpperReply, error) {
	out := new(UpperReply)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/Upper", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) NodeCredible(ctx context.Context, in *NodeCredibleData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/NodeCredible", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) Video(ctx context.Context, in *VideoData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/Video", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) Sensor(ctx context.Context, in *SensorData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/Sensor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) UserBehaviour(ctx context.Context, in *UserBehaviourData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/UserBehaviour", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) ServiceAccess(ctx context.Context, in *ServiceAccessData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/ServiceAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ToUpperServer is the server API for ToUpper service.
// All implementations should embed UnimplementedToUpperServer
// for forward compatibility
type ToUpperServer interface {
	Upper(context.Context, *UpperRequest) (*UpperReply, error)
	NodeCredible(context.Context, *NodeCredibleData) (*Response, error)
	Video(context.Context, *VideoData) (*Response, error)
	Sensor(context.Context, *SensorData) (*Response, error)
	UserBehaviour(context.Context, *UserBehaviourData) (*Response, error)
	ServiceAccess(context.Context, *ServiceAccessData) (*Response, error)
}

// UnimplementedToUpperServer should be embedded to have forward compatible implementations.
type UnimplementedToUpperServer struct {
}

func (UnimplementedToUpperServer) Upper(context.Context, *UpperRequest) (*UpperReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upper not implemented")
}
func (UnimplementedToUpperServer) NodeCredible(context.Context, *NodeCredibleData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeCredible not implemented")
}
func (UnimplementedToUpperServer) Video(context.Context, *VideoData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Video not implemented")
}
func (UnimplementedToUpperServer) Sensor(context.Context, *SensorData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sensor not implemented")
}
func (UnimplementedToUpperServer) UserBehaviour(context.Context, *UserBehaviourData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserBehaviour not implemented")
}
func (UnimplementedToUpperServer) ServiceAccess(context.Context, *ServiceAccessData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServiceAccess not implemented")
}

// UnsafeToUpperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ToUpperServer will
// result in compilation errors.
type UnsafeToUpperServer interface {
	mustEmbedUnimplementedToUpperServer()
}

func RegisterToUpperServer(s grpc.ServiceRegistrar, srv ToUpperServer) {
	s.RegisterService(&ToUpper_ServiceDesc, srv)
}

func _ToUpper_Upper_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpperRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).Upper(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/Upper",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).Upper(ctx, req.(*UpperRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_NodeCredible_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeCredibleData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).NodeCredible(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/NodeCredible",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).NodeCredible(ctx, req.(*NodeCredibleData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_Video_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).Video(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/Video",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).Video(ctx, req.(*VideoData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_Sensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).Sensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/Sensor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).Sensor(ctx, req.(*SensorData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_UserBehaviour_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserBehaviourData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).UserBehaviour(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/UserBehaviour",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).UserBehaviour(ctx, req.(*UserBehaviourData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_ServiceAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceAccessData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).ServiceAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/ServiceAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).ServiceAccess(ctx, req.(*ServiceAccessData))
	}
	return interceptor(ctx, in, info, handler)
}

// ToUpper_ServiceDesc is the grpc.ServiceDesc for ToUpper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ToUpper_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.ToUpper",
	HandlerType: (*ToUpperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Upper",
			Handler:    _ToUpper_Upper_Handler,
		},
		{
			MethodName: "NodeCredible",
			Handler:    _ToUpper_NodeCredible_Handler,
		},
		{
			MethodName: "Video",
			Handler:    _ToUpper_Video_Handler,
		},
		{
			MethodName: "Sensor",
			Handler:    _ToUpper_Sensor_Handler,
		},
		{
			MethodName: "UserBehaviour",
			Handler:    _ToUpper_UserBehaviour_Handler,
		},
		{
			MethodName: "ServiceAccess",
			Handler:    _ToUpper_ServiceAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}
