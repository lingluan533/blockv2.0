// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AccessLedgerServiceClient is the client API for AccessLedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccessLedgerServiceClient interface {
	AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error)
	AddMinuteBlock(ctx context.Context, in *MinuteTxBlock, opts ...grpc.CallOption) (*Response, error)
	AddTenMinuteBlock(ctx context.Context, in *TenMinuteTxBlock, opts ...grpc.CallOption) (*Response, error)
	AddDailyBlock(ctx context.Context, in *DailyTxBlock, opts ...grpc.CallOption) (*Response, error)
}

type accessLedgerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccessLedgerServiceClient(cc grpc.ClientConnInterface) AccessLedgerServiceClient {
	return &accessLedgerServiceClient{cc}
}

func (c *accessLedgerServiceClient) AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.AccessLedgerService/AddGenesisBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessLedgerServiceClient) AddMinuteBlock(ctx context.Context, in *MinuteTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.AccessLedgerService/AddMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessLedgerServiceClient) AddTenMinuteBlock(ctx context.Context, in *TenMinuteTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.AccessLedgerService/AddTenMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessLedgerServiceClient) AddDailyBlock(ctx context.Context, in *DailyTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.AccessLedgerService/AddDailyBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccessLedgerServiceServer is the server API for AccessLedgerService service.
// All implementations should embed UnimplementedAccessLedgerServiceServer
// for forward compatibility
type AccessLedgerServiceServer interface {
	AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error)
	AddMinuteBlock(context.Context, *MinuteTxBlock) (*Response, error)
	AddTenMinuteBlock(context.Context, *TenMinuteTxBlock) (*Response, error)
	AddDailyBlock(context.Context, *DailyTxBlock) (*Response, error)
}

// UnimplementedAccessLedgerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedAccessLedgerServiceServer struct {
}

func (UnimplementedAccessLedgerServiceServer) AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGenesisBlock not implemented")
}
func (UnimplementedAccessLedgerServiceServer) AddMinuteBlock(context.Context, *MinuteTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMinuteBlock not implemented")
}
func (UnimplementedAccessLedgerServiceServer) AddTenMinuteBlock(context.Context, *TenMinuteTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTenMinuteBlock not implemented")
}
func (UnimplementedAccessLedgerServiceServer) AddDailyBlock(context.Context, *DailyTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDailyBlock not implemented")
}

// UnsafeAccessLedgerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccessLedgerServiceServer will
// result in compilation errors.
type UnsafeAccessLedgerServiceServer interface {
	mustEmbedUnimplementedAccessLedgerServiceServer()
}

func RegisterAccessLedgerServiceServer(s grpc.ServiceRegistrar, srv AccessLedgerServiceServer) {
	s.RegisterService(&AccessLedgerService_ServiceDesc, srv)
}

func _AccessLedgerService_AddGenesisBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenesisBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessLedgerServiceServer).AddGenesisBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.AccessLedgerService/AddGenesisBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessLedgerServiceServer).AddGenesisBlock(ctx, req.(*GenesisBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessLedgerService_AddMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinuteTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessLedgerServiceServer).AddMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.AccessLedgerService/AddMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessLedgerServiceServer).AddMinuteBlock(ctx, req.(*MinuteTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessLedgerService_AddTenMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenMinuteTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessLedgerServiceServer).AddTenMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.AccessLedgerService/AddTenMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessLedgerServiceServer).AddTenMinuteBlock(ctx, req.(*TenMinuteTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessLedgerService_AddDailyBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DailyTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessLedgerServiceServer).AddDailyBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.AccessLedgerService/AddDailyBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessLedgerServiceServer).AddDailyBlock(ctx, req.(*DailyTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

// AccessLedgerService_ServiceDesc is the grpc.ServiceDesc for AccessLedgerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccessLedgerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.AccessLedgerService",
	HandlerType: (*AccessLedgerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddGenesisBlock",
			Handler:    _AccessLedgerService_AddGenesisBlock_Handler,
		},
		{
			MethodName: "AddMinuteBlock",
			Handler:    _AccessLedgerService_AddMinuteBlock_Handler,
		},
		{
			MethodName: "AddTenMinuteBlock",
			Handler:    _AccessLedgerService_AddTenMinuteBlock_Handler,
		},
		{
			MethodName: "AddDailyBlock",
			Handler:    _AccessLedgerService_AddDailyBlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}

// NodeLedgerServiceClient is the client API for NodeLedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeLedgerServiceClient interface {
	AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error)
	AddMinuteBlock(ctx context.Context, in *MinuteTxBlock, opts ...grpc.CallOption) (*Response, error)
	AddTenMinuteBlock(ctx context.Context, in *TenMinuteTxBlock, opts ...grpc.CallOption) (*Response, error)
	AddDailyBlock(ctx context.Context, in *DailyTxBlock, opts ...grpc.CallOption) (*Response, error)
}

type nodeLedgerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeLedgerServiceClient(cc grpc.ClientConnInterface) NodeLedgerServiceClient {
	return &nodeLedgerServiceClient{cc}
}

func (c *nodeLedgerServiceClient) AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.NodeLedgerService/AddGenesisBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeLedgerServiceClient) AddMinuteBlock(ctx context.Context, in *MinuteTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.NodeLedgerService/AddMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeLedgerServiceClient) AddTenMinuteBlock(ctx context.Context, in *TenMinuteTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.NodeLedgerService/AddTenMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeLedgerServiceClient) AddDailyBlock(ctx context.Context, in *DailyTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.NodeLedgerService/AddDailyBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeLedgerServiceServer is the server API for NodeLedgerService service.
// All implementations should embed UnimplementedNodeLedgerServiceServer
// for forward compatibility
type NodeLedgerServiceServer interface {
	AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error)
	AddMinuteBlock(context.Context, *MinuteTxBlock) (*Response, error)
	AddTenMinuteBlock(context.Context, *TenMinuteTxBlock) (*Response, error)
	AddDailyBlock(context.Context, *DailyTxBlock) (*Response, error)
}

// UnimplementedNodeLedgerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedNodeLedgerServiceServer struct {
}

func (UnimplementedNodeLedgerServiceServer) AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGenesisBlock not implemented")
}
func (UnimplementedNodeLedgerServiceServer) AddMinuteBlock(context.Context, *MinuteTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMinuteBlock not implemented")
}
func (UnimplementedNodeLedgerServiceServer) AddTenMinuteBlock(context.Context, *TenMinuteTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTenMinuteBlock not implemented")
}
func (UnimplementedNodeLedgerServiceServer) AddDailyBlock(context.Context, *DailyTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDailyBlock not implemented")
}

// UnsafeNodeLedgerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeLedgerServiceServer will
// result in compilation errors.
type UnsafeNodeLedgerServiceServer interface {
	mustEmbedUnimplementedNodeLedgerServiceServer()
}

func RegisterNodeLedgerServiceServer(s grpc.ServiceRegistrar, srv NodeLedgerServiceServer) {
	s.RegisterService(&NodeLedgerService_ServiceDesc, srv)
}

func _NodeLedgerService_AddGenesisBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenesisBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeLedgerServiceServer).AddGenesisBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NodeLedgerService/AddGenesisBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeLedgerServiceServer).AddGenesisBlock(ctx, req.(*GenesisBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeLedgerService_AddMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinuteTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeLedgerServiceServer).AddMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NodeLedgerService/AddMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeLedgerServiceServer).AddMinuteBlock(ctx, req.(*MinuteTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeLedgerService_AddTenMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenMinuteTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeLedgerServiceServer).AddTenMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NodeLedgerService/AddTenMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeLedgerServiceServer).AddTenMinuteBlock(ctx, req.(*TenMinuteTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeLedgerService_AddDailyBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DailyTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeLedgerServiceServer).AddDailyBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.NodeLedgerService/AddDailyBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeLedgerServiceServer).AddDailyBlock(ctx, req.(*DailyTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeLedgerService_ServiceDesc is the grpc.ServiceDesc for NodeLedgerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeLedgerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NodeLedgerService",
	HandlerType: (*NodeLedgerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddGenesisBlock",
			Handler:    _NodeLedgerService_AddGenesisBlock_Handler,
		},
		{
			MethodName: "AddMinuteBlock",
			Handler:    _NodeLedgerService_AddMinuteBlock_Handler,
		},
		{
			MethodName: "AddTenMinuteBlock",
			Handler:    _NodeLedgerService_AddTenMinuteBlock_Handler,
		},
		{
			MethodName: "AddDailyBlock",
			Handler:    _NodeLedgerService_AddDailyBlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}

// SensorLedgerServiceClient is the client API for SensorLedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SensorLedgerServiceClient interface {
	AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error)
	AddMinuteBlock(ctx context.Context, in *MinuteTxBlock, opts ...grpc.CallOption) (*Response, error)
	AddTenMinuteBlock(ctx context.Context, in *TenMinuteTxBlock, opts ...grpc.CallOption) (*Response, error)
	AddDailyBlock(ctx context.Context, in *DailyTxBlock, opts ...grpc.CallOption) (*Response, error)
}

type sensorLedgerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSensorLedgerServiceClient(cc grpc.ClientConnInterface) SensorLedgerServiceClient {
	return &sensorLedgerServiceClient{cc}
}

func (c *sensorLedgerServiceClient) AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.SensorLedgerService/AddGenesisBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorLedgerServiceClient) AddMinuteBlock(ctx context.Context, in *MinuteTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.SensorLedgerService/AddMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorLedgerServiceClient) AddTenMinuteBlock(ctx context.Context, in *TenMinuteTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.SensorLedgerService/AddTenMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorLedgerServiceClient) AddDailyBlock(ctx context.Context, in *DailyTxBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.SensorLedgerService/AddDailyBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SensorLedgerServiceServer is the server API for SensorLedgerService service.
// All implementations should embed UnimplementedSensorLedgerServiceServer
// for forward compatibility
type SensorLedgerServiceServer interface {
	AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error)
	AddMinuteBlock(context.Context, *MinuteTxBlock) (*Response, error)
	AddTenMinuteBlock(context.Context, *TenMinuteTxBlock) (*Response, error)
	AddDailyBlock(context.Context, *DailyTxBlock) (*Response, error)
}

// UnimplementedSensorLedgerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedSensorLedgerServiceServer struct {
}

func (UnimplementedSensorLedgerServiceServer) AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGenesisBlock not implemented")
}
func (UnimplementedSensorLedgerServiceServer) AddMinuteBlock(context.Context, *MinuteTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMinuteBlock not implemented")
}
func (UnimplementedSensorLedgerServiceServer) AddTenMinuteBlock(context.Context, *TenMinuteTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTenMinuteBlock not implemented")
}
func (UnimplementedSensorLedgerServiceServer) AddDailyBlock(context.Context, *DailyTxBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDailyBlock not implemented")
}

// UnsafeSensorLedgerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SensorLedgerServiceServer will
// result in compilation errors.
type UnsafeSensorLedgerServiceServer interface {
	mustEmbedUnimplementedSensorLedgerServiceServer()
}

func RegisterSensorLedgerServiceServer(s grpc.ServiceRegistrar, srv SensorLedgerServiceServer) {
	s.RegisterService(&SensorLedgerService_ServiceDesc, srv)
}

func _SensorLedgerService_AddGenesisBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenesisBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorLedgerServiceServer).AddGenesisBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.SensorLedgerService/AddGenesisBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorLedgerServiceServer).AddGenesisBlock(ctx, req.(*GenesisBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorLedgerService_AddMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinuteTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorLedgerServiceServer).AddMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.SensorLedgerService/AddMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorLedgerServiceServer).AddMinuteBlock(ctx, req.(*MinuteTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorLedgerService_AddTenMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenMinuteTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorLedgerServiceServer).AddTenMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.SensorLedgerService/AddTenMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorLedgerServiceServer).AddTenMinuteBlock(ctx, req.(*TenMinuteTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorLedgerService_AddDailyBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DailyTxBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorLedgerServiceServer).AddDailyBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.SensorLedgerService/AddDailyBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorLedgerServiceServer).AddDailyBlock(ctx, req.(*DailyTxBlock))
	}
	return interceptor(ctx, in, info, handler)
}

// SensorLedgerService_ServiceDesc is the grpc.ServiceDesc for SensorLedgerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SensorLedgerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.SensorLedgerService",
	HandlerType: (*SensorLedgerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddGenesisBlock",
			Handler:    _SensorLedgerService_AddGenesisBlock_Handler,
		},
		{
			MethodName: "AddMinuteBlock",
			Handler:    _SensorLedgerService_AddMinuteBlock_Handler,
		},
		{
			MethodName: "AddTenMinuteBlock",
			Handler:    _SensorLedgerService_AddTenMinuteBlock_Handler,
		},
		{
			MethodName: "AddDailyBlock",
			Handler:    _SensorLedgerService_AddDailyBlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}

// UserLedgerServiceClient is the client API for UserLedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserLedgerServiceClient interface {
	AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error)
	AddMinuteBlock(ctx context.Context, in *MinuteDataBlock, opts ...grpc.CallOption) (*Response, error)
	AddTenMinuteBlock(ctx context.Context, in *TenMinuteDataBlock, opts ...grpc.CallOption) (*Response, error)
	AddDailyBlock(ctx context.Context, in *DailyDataBlock, opts ...grpc.CallOption) (*Response, error)
}

type userLedgerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserLedgerServiceClient(cc grpc.ClientConnInterface) UserLedgerServiceClient {
	return &userLedgerServiceClient{cc}
}

func (c *userLedgerServiceClient) AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.UserLedgerService/AddGenesisBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLedgerServiceClient) AddMinuteBlock(ctx context.Context, in *MinuteDataBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.UserLedgerService/AddMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLedgerServiceClient) AddTenMinuteBlock(ctx context.Context, in *TenMinuteDataBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.UserLedgerService/AddTenMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLedgerServiceClient) AddDailyBlock(ctx context.Context, in *DailyDataBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.UserLedgerService/AddDailyBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserLedgerServiceServer is the server API for UserLedgerService service.
// All implementations should embed UnimplementedUserLedgerServiceServer
// for forward compatibility
type UserLedgerServiceServer interface {
	AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error)
	AddMinuteBlock(context.Context, *MinuteDataBlock) (*Response, error)
	AddTenMinuteBlock(context.Context, *TenMinuteDataBlock) (*Response, error)
	AddDailyBlock(context.Context, *DailyDataBlock) (*Response, error)
}

// UnimplementedUserLedgerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedUserLedgerServiceServer struct {
}

func (UnimplementedUserLedgerServiceServer) AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGenesisBlock not implemented")
}
func (UnimplementedUserLedgerServiceServer) AddMinuteBlock(context.Context, *MinuteDataBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMinuteBlock not implemented")
}
func (UnimplementedUserLedgerServiceServer) AddTenMinuteBlock(context.Context, *TenMinuteDataBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTenMinuteBlock not implemented")
}
func (UnimplementedUserLedgerServiceServer) AddDailyBlock(context.Context, *DailyDataBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDailyBlock not implemented")
}

// UnsafeUserLedgerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserLedgerServiceServer will
// result in compilation errors.
type UnsafeUserLedgerServiceServer interface {
	mustEmbedUnimplementedUserLedgerServiceServer()
}

func RegisterUserLedgerServiceServer(s grpc.ServiceRegistrar, srv UserLedgerServiceServer) {
	s.RegisterService(&UserLedgerService_ServiceDesc, srv)
}

func _UserLedgerService_AddGenesisBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenesisBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLedgerServiceServer).AddGenesisBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.UserLedgerService/AddGenesisBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLedgerServiceServer).AddGenesisBlock(ctx, req.(*GenesisBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLedgerService_AddMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinuteDataBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLedgerServiceServer).AddMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.UserLedgerService/AddMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLedgerServiceServer).AddMinuteBlock(ctx, req.(*MinuteDataBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLedgerService_AddTenMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenMinuteDataBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLedgerServiceServer).AddTenMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.UserLedgerService/AddTenMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLedgerServiceServer).AddTenMinuteBlock(ctx, req.(*TenMinuteDataBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLedgerService_AddDailyBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DailyDataBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLedgerServiceServer).AddDailyBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.UserLedgerService/AddDailyBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLedgerServiceServer).AddDailyBlock(ctx, req.(*DailyDataBlock))
	}
	return interceptor(ctx, in, info, handler)
}

// UserLedgerService_ServiceDesc is the grpc.ServiceDesc for UserLedgerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserLedgerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.UserLedgerService",
	HandlerType: (*UserLedgerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddGenesisBlock",
			Handler:    _UserLedgerService_AddGenesisBlock_Handler,
		},
		{
			MethodName: "AddMinuteBlock",
			Handler:    _UserLedgerService_AddMinuteBlock_Handler,
		},
		{
			MethodName: "AddTenMinuteBlock",
			Handler:    _UserLedgerService_AddTenMinuteBlock_Handler,
		},
		{
			MethodName: "AddDailyBlock",
			Handler:    _UserLedgerService_AddDailyBlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}

// VideoLedgerServiceClient is the client API for VideoLedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VideoLedgerServiceClient interface {
	AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error)
	AddMinuteBlock(ctx context.Context, in *MinuteDataBlock, opts ...grpc.CallOption) (*Response, error)
	AddTenMinuteBlock(ctx context.Context, in *TenMinuteDataBlock, opts ...grpc.CallOption) (*Response, error)
	AddDailyBlock(ctx context.Context, in *DailyDataBlock, opts ...grpc.CallOption) (*Response, error)
}

type videoLedgerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVideoLedgerServiceClient(cc grpc.ClientConnInterface) VideoLedgerServiceClient {
	return &videoLedgerServiceClient{cc}
}

func (c *videoLedgerServiceClient) AddGenesisBlock(ctx context.Context, in *GenesisBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.VideoLedgerService/AddGenesisBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoLedgerServiceClient) AddMinuteBlock(ctx context.Context, in *MinuteDataBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.VideoLedgerService/AddMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoLedgerServiceClient) AddTenMinuteBlock(ctx context.Context, in *TenMinuteDataBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.VideoLedgerService/AddTenMinuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoLedgerServiceClient) AddDailyBlock(ctx context.Context, in *DailyDataBlock, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.VideoLedgerService/AddDailyBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VideoLedgerServiceServer is the server API for VideoLedgerService service.
// All implementations should embed UnimplementedVideoLedgerServiceServer
// for forward compatibility
type VideoLedgerServiceServer interface {
	AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error)
	AddMinuteBlock(context.Context, *MinuteDataBlock) (*Response, error)
	AddTenMinuteBlock(context.Context, *TenMinuteDataBlock) (*Response, error)
	AddDailyBlock(context.Context, *DailyDataBlock) (*Response, error)
}

// UnimplementedVideoLedgerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedVideoLedgerServiceServer struct {
}

func (UnimplementedVideoLedgerServiceServer) AddGenesisBlock(context.Context, *GenesisBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGenesisBlock not implemented")
}
func (UnimplementedVideoLedgerServiceServer) AddMinuteBlock(context.Context, *MinuteDataBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMinuteBlock not implemented")
}
func (UnimplementedVideoLedgerServiceServer) AddTenMinuteBlock(context.Context, *TenMinuteDataBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTenMinuteBlock not implemented")
}
func (UnimplementedVideoLedgerServiceServer) AddDailyBlock(context.Context, *DailyDataBlock) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDailyBlock not implemented")
}

// UnsafeVideoLedgerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VideoLedgerServiceServer will
// result in compilation errors.
type UnsafeVideoLedgerServiceServer interface {
	mustEmbedUnimplementedVideoLedgerServiceServer()
}

func RegisterVideoLedgerServiceServer(s grpc.ServiceRegistrar, srv VideoLedgerServiceServer) {
	s.RegisterService(&VideoLedgerService_ServiceDesc, srv)
}

func _VideoLedgerService_AddGenesisBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenesisBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoLedgerServiceServer).AddGenesisBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.VideoLedgerService/AddGenesisBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoLedgerServiceServer).AddGenesisBlock(ctx, req.(*GenesisBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoLedgerService_AddMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinuteDataBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoLedgerServiceServer).AddMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.VideoLedgerService/AddMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoLedgerServiceServer).AddMinuteBlock(ctx, req.(*MinuteDataBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoLedgerService_AddTenMinuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenMinuteDataBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoLedgerServiceServer).AddTenMinuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.VideoLedgerService/AddTenMinuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoLedgerServiceServer).AddTenMinuteBlock(ctx, req.(*TenMinuteDataBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoLedgerService_AddDailyBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DailyDataBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoLedgerServiceServer).AddDailyBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.VideoLedgerService/AddDailyBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoLedgerServiceServer).AddDailyBlock(ctx, req.(*DailyDataBlock))
	}
	return interceptor(ctx, in, info, handler)
}

// VideoLedgerService_ServiceDesc is the grpc.ServiceDesc for VideoLedgerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VideoLedgerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.VideoLedgerService",
	HandlerType: (*VideoLedgerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddGenesisBlock",
			Handler:    _VideoLedgerService_AddGenesisBlock_Handler,
		},
		{
			MethodName: "AddMinuteBlock",
			Handler:    _VideoLedgerService_AddMinuteBlock_Handler,
		},
		{
			MethodName: "AddTenMinuteBlock",
			Handler:    _VideoLedgerService_AddTenMinuteBlock_Handler,
		},
		{
			MethodName: "AddDailyBlock",
			Handler:    _VideoLedgerService_AddDailyBlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryServiceClient interface {
	//查询所有的存证记录
	QueryAllDataReceipts(ctx context.Context, in *RequestAllDataReceipts, opts ...grpc.CallOption) (*ResponseAllDataReceipts, error)
	QueryBlockBatch(ctx context.Context, in *RequestDataBatch, opts ...grpc.CallOption) (*ResponseDataBatchBlock, error)
	QueryBlock(ctx context.Context, in *RequestBlock, opts ...grpc.CallOption) (*ResponseBlock, error)
	QueryGenesisBlock(ctx context.Context, in *RequestGenesisBlock, opts ...grpc.CallOption) (*ResponseGenesisBlock, error)
	QueryTx(ctx context.Context, in *RequestTx, opts ...grpc.CallOption) (*ResponseTx, error)
	QueryDataReceipt(ctx context.Context, in *RequestDataReceipt, opts ...grpc.CallOption) (*ResponseDataReceipt, error)
}

type queryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryServiceClient(cc grpc.ClientConnInterface) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) QueryAllDataReceipts(ctx context.Context, in *RequestAllDataReceipts, opts ...grpc.CallOption) (*ResponseAllDataReceipts, error) {
	out := new(ResponseAllDataReceipts)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryAllDataReceipts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryBlockBatch(ctx context.Context, in *RequestDataBatch, opts ...grpc.CallOption) (*ResponseDataBatchBlock, error) {
	out := new(ResponseDataBatchBlock)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryBlockBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryBlock(ctx context.Context, in *RequestBlock, opts ...grpc.CallOption) (*ResponseBlock, error) {
	out := new(ResponseBlock)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryGenesisBlock(ctx context.Context, in *RequestGenesisBlock, opts ...grpc.CallOption) (*ResponseGenesisBlock, error) {
	out := new(ResponseGenesisBlock)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryGenesisBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryTx(ctx context.Context, in *RequestTx, opts ...grpc.CallOption) (*ResponseTx, error) {
	out := new(ResponseTx)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) QueryDataReceipt(ctx context.Context, in *RequestDataReceipt, opts ...grpc.CallOption) (*ResponseDataReceipt, error) {
	out := new(ResponseDataReceipt)
	err := c.cc.Invoke(ctx, "/rpc.QueryService/queryDataReceipt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServiceServer is the server API for QueryService service.
// All implementations should embed UnimplementedQueryServiceServer
// for forward compatibility
type QueryServiceServer interface {
	//查询所有的存证记录
	QueryAllDataReceipts(context.Context, *RequestAllDataReceipts) (*ResponseAllDataReceipts, error)
	QueryBlockBatch(context.Context, *RequestDataBatch) (*ResponseDataBatchBlock, error)
	QueryBlock(context.Context, *RequestBlock) (*ResponseBlock, error)
	QueryGenesisBlock(context.Context, *RequestGenesisBlock) (*ResponseGenesisBlock, error)
	QueryTx(context.Context, *RequestTx) (*ResponseTx, error)
	QueryDataReceipt(context.Context, *RequestDataReceipt) (*ResponseDataReceipt, error)
}

// UnimplementedQueryServiceServer should be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (UnimplementedQueryServiceServer) QueryAllDataReceipts(context.Context, *RequestAllDataReceipts) (*ResponseAllDataReceipts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllDataReceipts not implemented")
}
func (UnimplementedQueryServiceServer) QueryBlockBatch(context.Context, *RequestDataBatch) (*ResponseDataBatchBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryBlockBatch not implemented")
}
func (UnimplementedQueryServiceServer) QueryBlock(context.Context, *RequestBlock) (*ResponseBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryBlock not implemented")
}
func (UnimplementedQueryServiceServer) QueryGenesisBlock(context.Context, *RequestGenesisBlock) (*ResponseGenesisBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGenesisBlock not implemented")
}
func (UnimplementedQueryServiceServer) QueryTx(context.Context, *RequestTx) (*ResponseTx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTx not implemented")
}
func (UnimplementedQueryServiceServer) QueryDataReceipt(context.Context, *RequestDataReceipt) (*ResponseDataReceipt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDataReceipt not implemented")
}

// UnsafeQueryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServiceServer will
// result in compilation errors.
type UnsafeQueryServiceServer interface {
	mustEmbedUnimplementedQueryServiceServer()
}

func RegisterQueryServiceServer(s grpc.ServiceRegistrar, srv QueryServiceServer) {
	s.RegisterService(&QueryService_ServiceDesc, srv)
}

func _QueryService_QueryAllDataReceipts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestAllDataReceipts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryAllDataReceipts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryAllDataReceipts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryAllDataReceipts(ctx, req.(*RequestAllDataReceipts))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryBlockBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDataBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryBlockBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryBlockBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryBlockBatch(ctx, req.(*RequestDataBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryBlock(ctx, req.(*RequestBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryGenesisBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGenesisBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryGenesisBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryGenesisBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryGenesisBlock(ctx, req.(*RequestGenesisBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryTx(ctx, req.(*RequestTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_QueryDataReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDataReceipt)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).QueryDataReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.QueryService/queryDataReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).QueryDataReceipt(ctx, req.(*RequestDataReceipt))
	}
	return interceptor(ctx, in, info, handler)
}

// QueryService_ServiceDesc is the grpc.ServiceDesc for QueryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "queryAllDataReceipts",
			Handler:    _QueryService_QueryAllDataReceipts_Handler,
		},
		{
			MethodName: "queryBlockBatch",
			Handler:    _QueryService_QueryBlockBatch_Handler,
		},
		{
			MethodName: "queryBlock",
			Handler:    _QueryService_QueryBlock_Handler,
		},
		{
			MethodName: "queryGenesisBlock",
			Handler:    _QueryService_QueryGenesisBlock_Handler,
		},
		{
			MethodName: "queryTx",
			Handler:    _QueryService_QueryTx_Handler,
		},
		{
			MethodName: "queryDataReceipt",
			Handler:    _QueryService_QueryDataReceipt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}

// ToUpperClient is the client API for ToUpper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ToUpperClient interface {
	Upper(ctx context.Context, in *UpperRequest, opts ...grpc.CallOption) (*UpperReply, error)
	NodeCredible(ctx context.Context, in *NodeCredibleData, opts ...grpc.CallOption) (*Response, error)
	Video(ctx context.Context, in *VideoData, opts ...grpc.CallOption) (*Response, error)
	Sensor(ctx context.Context, in *SensorData, opts ...grpc.CallOption) (*Response, error)
	UserBehaviour(ctx context.Context, in *UserBehaviourData, opts ...grpc.CallOption) (*Response, error)
	ServiceAccess(ctx context.Context, in *ServiceAccessData, opts ...grpc.CallOption) (*Response, error)
}

type toUpperClient struct {
	cc grpc.ClientConnInterface
}

func NewToUpperClient(cc grpc.ClientConnInterface) ToUpperClient {
	return &toUpperClient{cc}
}

func (c *toUpperClient) Upper(ctx context.Context, in *UpperRequest, opts ...grpc.CallOption) (*UpperReply, error) {
	out := new(UpperReply)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/Upper", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) NodeCredible(ctx context.Context, in *NodeCredibleData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/NodeCredible", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) Video(ctx context.Context, in *VideoData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/Video", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) Sensor(ctx context.Context, in *SensorData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/Sensor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) UserBehaviour(ctx context.Context, in *UserBehaviourData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/UserBehaviour", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toUpperClient) ServiceAccess(ctx context.Context, in *ServiceAccessData, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/rpc.ToUpper/ServiceAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ToUpperServer is the server API for ToUpper service.
// All implementations should embed UnimplementedToUpperServer
// for forward compatibility
type ToUpperServer interface {
	Upper(context.Context, *UpperRequest) (*UpperReply, error)
	NodeCredible(context.Context, *NodeCredibleData) (*Response, error)
	Video(context.Context, *VideoData) (*Response, error)
	Sensor(context.Context, *SensorData) (*Response, error)
	UserBehaviour(context.Context, *UserBehaviourData) (*Response, error)
	ServiceAccess(context.Context, *ServiceAccessData) (*Response, error)
}

// UnimplementedToUpperServer should be embedded to have forward compatible implementations.
type UnimplementedToUpperServer struct {
}

func (UnimplementedToUpperServer) Upper(context.Context, *UpperRequest) (*UpperReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upper not implemented")
}
func (UnimplementedToUpperServer) NodeCredible(context.Context, *NodeCredibleData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeCredible not implemented")
}
func (UnimplementedToUpperServer) Video(context.Context, *VideoData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Video not implemented")
}
func (UnimplementedToUpperServer) Sensor(context.Context, *SensorData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sensor not implemented")
}
func (UnimplementedToUpperServer) UserBehaviour(context.Context, *UserBehaviourData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserBehaviour not implemented")
}
func (UnimplementedToUpperServer) ServiceAccess(context.Context, *ServiceAccessData) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServiceAccess not implemented")
}

// UnsafeToUpperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ToUpperServer will
// result in compilation errors.
type UnsafeToUpperServer interface {
	mustEmbedUnimplementedToUpperServer()
}

func RegisterToUpperServer(s grpc.ServiceRegistrar, srv ToUpperServer) {
	s.RegisterService(&ToUpper_ServiceDesc, srv)
}

func _ToUpper_Upper_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpperRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).Upper(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/Upper",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).Upper(ctx, req.(*UpperRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_NodeCredible_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeCredibleData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).NodeCredible(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/NodeCredible",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).NodeCredible(ctx, req.(*NodeCredibleData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_Video_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).Video(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/Video",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).Video(ctx, req.(*VideoData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_Sensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).Sensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/Sensor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).Sensor(ctx, req.(*SensorData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_UserBehaviour_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserBehaviourData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).UserBehaviour(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/UserBehaviour",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).UserBehaviour(ctx, req.(*UserBehaviourData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ToUpper_ServiceAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceAccessData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToUpperServer).ServiceAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ToUpper/ServiceAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToUpperServer).ServiceAccess(ctx, req.(*ServiceAccessData))
	}
	return interceptor(ctx, in, info, handler)
}

// ToUpper_ServiceDesc is the grpc.ServiceDesc for ToUpper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ToUpper_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.ToUpper",
	HandlerType: (*ToUpperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Upper",
			Handler:    _ToUpper_Upper_Handler,
		},
		{
			MethodName: "NodeCredible",
			Handler:    _ToUpper_NodeCredible_Handler,
		},
		{
			MethodName: "Video",
			Handler:    _ToUpper_Video_Handler,
		},
		{
			MethodName: "Sensor",
			Handler:    _ToUpper_Sensor_Handler,
		},
		{
			MethodName: "UserBehaviour",
			Handler:    _ToUpper_UserBehaviour_Handler,
		},
		{
			MethodName: "ServiceAccess",
			Handler:    _ToUpper_ServiceAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "block.proto",
}
